---
export interface Props {
  label?: string;
  durationMs?: number;
  targetSelector?: string;
  overlaySelector?: string;     // optional; leave blank to keep overlay visible
  icon?: string | { src: string };
  iconWidth?: string;
  hideOnComplete?: boolean;
  strokeRadius?: number;        // corners for the animated stroke
  strokeStart?: "bottom-center" | "top-center"; // NEW: start point control
  class?: string;
}

const {
  label = "ENTER",
  durationMs = 3000,
  targetSelector = "#enter-stage",
  overlaySelector = "",
  icon,
  iconWidth = "16px",
  hideOnComplete = true,
  strokeRadius = 10,
  strokeStart = "bottom-center",       
  class: className = "",
} = Astro.props;

const iconUrl = icon ? (typeof icon === "string" ? icon : icon.src) : null;
---

<style>
  .enter-wrap{position:absolute;left:49.5%;bottom:20%;transform:translateX(-50%);z-index:70}
  .enter-btn{
    -webkit-tap-highlight-color:transparent;
    position:relative;display:inline-flex;align-items:center;gap:.5rem;
    padding:14px 28px;border-radius:10px;border:0;cursor:pointer;
    background:#ef4444;color:#fff;font-weight:700;letter-spacing:.06em;
    box-shadow:0 6px 18px rgba(239,68,68,.25);
    transform:scale(var(--press,1));filter:brightness(var(--b,1));
    transition:transform 150ms ease,filter 120ms ease,opacity 200ms ease
  }
  .enter-btn:hover{--b:.92}
  .enter-btn:active{--b:.85;--press:1.03}
  .enter-btn[aria-disabled="true"]{cursor:default;opacity:.65;--b:1}

  .enter-svg{position:absolute;inset:-6px;width:calc(100% + 12px);height:calc(100% + 12px);pointer-events:none}
  .enter-stroke{fill:none;stroke:#fff;stroke-width:3;stroke-linecap:round;opacity:0;transition:opacity 100ms ease}

  .icon{width:var(--iw,16px);height:auto;display:block;pointer-events:none}
  .hint{position:absolute;top:100%;left:50%;transform:translate(-50%,8px);font-size:.75rem;color:#fca5a5}
  @media (prefers-reduced-motion:reduce){.enter-btn{transition:none}}
</style>

<div
  class={`enter-wrap ${className}`}
  data-target={targetSelector}
  data-dur={String(durationMs)}
  data-overlay={overlaySelector}
  data-hide={hideOnComplete ? "1" : "0"}
  data-rx={String(strokeRadius)}
  data-start={strokeStart}
  style={`--iw:${iconWidth};`}
>
  <button class="enter-btn" type="button" aria-pressed="false">
    <span>{label}</span>
    {iconUrl && <img class="icon" src={iconUrl} alt="" aria-hidden="true" />}

    <!-- Rounded-rect stroke; weâ€™ll shift dash start to bottom-center in JS -->
    <svg class="enter-svg" viewBox="0 0 200 72" preserveAspectRatio="none">
      <rect class="enter-stroke" x="1.5" y="1.5" width="197" height="69" rx={strokeRadius} ry={strokeRadius} />
    </svg>

    <span class="hint" aria-hidden="true"></span>
  </button>
</div>

<script is:inline>
(() => {
  const wrap = document.currentScript?.previousElementSibling;
  if (!wrap) return;
  const btn   = wrap.querySelector('.enter-btn');
  const rect  = wrap.querySelector('.enter-stroke');
  const targetSel  = wrap.getAttribute('data-target') || '#enter-stage';
  const overlaySel = wrap.getAttribute('data-overlay') || '';
  const hideOnDone = wrap.getAttribute('data-hide') === '1';
  const dur        = parseInt(wrap.getAttribute('data-dur') || '3000', 10);
  const rx         = parseFloat(wrap.getAttribute('data-rx') || '10');
  const startMode  = (wrap.getAttribute('data-start') || 'bottom-center').toLowerCase();
  const target     = document.querySelector(targetSel);
  if (!btn || !rect || !target) return;

  let total = 0, holding = false, startT = 0, rafId = 0;

  // Compute dashoffset so drawing starts at requested point on the rounded-rect
  function setDashStart(){
    // geometry from rect attrs (in the viewBox units)
    const W = parseFloat(rect.getAttribute('width')  || '197');
    const H = parseFloat(rect.getAttribute('height') || '69');
    const r = Math.min(rx, Math.min(W, H) * 0.5);
    try { total = rect.getTotalLength(); } catch { total = 2*(W+H-2*r) + 2*Math.PI*r; }

    // lengths for convenience
    const flatTop   = Math.max(0, W - 2*r);
    const flatSide  = Math.max(0, H - 2*r);
    const qArc      = Math.PI * r / 2; // quarter-circle arc length

    let offset = 0;
    if (startMode === 'top-center'){
      offset = flatTop / 2;
    } else {
      // bottom-center along the clockwise path starting at the top-left flat-start
      // path goes: top flat -> TR arc -> right flat -> BR arc -> bottom flat (right->left)
      // we want halfway across the bottom flat: add flatTop + qArc + flatSide + qArc + (flatBottom/2)
      offset = 0.5* flatTop + 2 * qArc + flatSide
    }

    rect.style.strokeDashoffset = String(offset);
    rect.style.strokeDasharray  = `0 ${total}`;
    rect.style.opacity = '0'; // hidden until press
  }

  function reset(){
    holding = false;
    btn.setAttribute('aria-pressed','false');
    btn.style.setProperty('--press','1');
    rect.style.strokeDasharray = `0 ${total}`;
    rect.style.opacity = '0';
    cancelAnimationFrame(rafId);
  }

  function maybeFadeOverlay(){
    if (!overlaySel) return; // default: keep overlay visible
    const el = document.querySelector(overlaySel);
    if (!el) return;
    el.style.transition = 'opacity 220ms ease';
    el.style.opacity = '0';
    setTimeout(() => { el.style.display = 'none'; }, 240);
  }

  function complete(){
    btn.setAttribute('aria-disabled','true');
    rect.style.strokeDasharray = `${total} 0`;
    target.setAttribute('data-entered','true');     // carousel will read this
    maybeFadeOverlay();                              // default no-op
    window.dispatchEvent(new CustomEvent('enter:activated', { detail:{ selector: targetSel }}));
    if (hideOnDone){ wrap.style.display = 'none'; }
  }

  function tick(now){
    if (!holding) return;
    const t = Math.min(1, (now - startT) / dur);
    const seg = t * total;
    rect.style.strokeDasharray = `${seg} ${Math.max(0,total - seg)}`;
    if (t >= 1){ complete(); return; }
    rafId = requestAnimationFrame(tick);
  }

  const down = () => {
    if (target.getAttribute('data-entered') === 'true') return;
    holding = true;
    btn.setAttribute('aria-pressed','true');
    btn.style.setProperty('--press','1.03');
    startT = performance.now();
    rect.style.opacity = '1';
    rafId = requestAnimationFrame(tick);
  };
  const up = () => { if (holding) reset(); };

  btn.addEventListener('pointerdown', down, { passive:true });
  btn.addEventListener('pointerup', up, { passive:true });
  btn.addEventListener('pointercancel', up, { passive:true });
  btn.addEventListener('pointerleave', up, { passive:true });
  btn.addEventListener('keydown', e => { if (e.key === ' ' || e.key === 'Enter') down(); });
  btn.addEventListener('keyup',   e => { if (e.key === ' ' || e.key === 'Enter') up(); });

  setDashStart();
  addEventListener('resize', setDashStart, { passive:true });
})();
</script>

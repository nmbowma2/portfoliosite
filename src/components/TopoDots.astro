---
/* TopoDots — transparent canvas with smooth feathered valley */
---
<style>
  .topo-wrap{
    position:relative; width:100%; height:min(80vh,900px);
    overflow:hidden; background:transparent; border-radius:12px;
  }
  canvas#topo{
    position:absolute; inset:0; width:100%; height:100%;
    display:block; background:transparent;
  }
</style>

<div class="topo-wrap" aria-hidden="true">
  <canvas id="topo"></canvas>
</div>

<script>
// @ts-nocheck

// ---------- CONFIG (edit these) ----------
const CONFIG = {
  // visual
  spacing: 21,          // base spacing in CSS px (auto-raised if too many dots)
  baseRadius: 2.8,      // dot radius in CSS px (before proximity shaping)
  amp: 10,              // displacement near cursor (CSS px)
  sigma: 100,           // influence radius (CSS px)
  grayBase: 235,        // dot grey far from cursor (0..255)
  grayDepth: 60,        // extra darkening toward center (0..255)

  // NEW: smooth feathering outside the local radius (multiple of sigma)
  localRadiusMult: 0.6,     // center influence radius
  edgeFeatherMult: 0.9,     // feather width = this * sigma (set 0.5..1.5)

  // chromatic aberration (per-channel tiny offsets)
  chroma: {
    enabled: true,
    mode: "lighter",    // "lighter" for additive on dark bg, else "source-over"
    alphaScale: 0.65,   // per-channel alpha multiplier (0..1)
    r: { x:  1.2, y: 0 },
    g: { x: -2.5, y: 1.0 },
    b: { x: -1.5, y: 0 },
  },

  // performance
  maxDots: 9500,        // hard cap; spacing auto-adjusts to stay under this
  dprCap: 1.8,          // cap devicePixelRatio to avoid overdraw
  targetFPS: 60,        // render cadence; 60 or 30
};
// -----------------------------------------

const el = document.getElementById("topo");
if (!(el instanceof HTMLCanvasElement)) { console.warn("[TopoDots] canvas missing"); }
else {
  const canvas = el;
  const ctx = canvas.getContext("2d", { alpha:true });
  if (!ctx) { console.warn("[TopoDots] 2D context unavailable"); }
  else {
    ctx.imageSmoothingEnabled = false; // crisper tiny squares

    // Accessibility / progressive reduction
    const prefersReduced = window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches ?? false;
    if (prefersReduced) {
      CONFIG.amp = Math.min(CONFIG.amp, 6);
      CONFIG.chroma.enabled = false;
    }

    // State (keep allocations outside frame loop)
    let dpr = 1, W = 0, H = 0, spacingDevice = 0;
    let points = /** @type {{x:number,y:number}[]} */ ([]);
    const state = { tx:0, ty:0, px:0, py:0 }; // smoothed pointer

    // Pointer (no allocations inside handler)
    function setTargetFromEvent(e){
      // offsetX/Y are already in CSS px relative to canvas box
      state.tx = e.offsetX * dpr;
      state.ty = e.offsetY * dpr;
    }
    canvas.addEventListener("pointermove", setTargetFromEvent, { passive:true });
    canvas.addEventListener("pointerdown",  setTargetFromEvent, { passive:true });
    canvas.addEventListener("pointerleave", () => { /* keep last target; no animation stall */ }, { passive:true });

    // Resize with auto density control
    function rebuildGrid(){
      const rect = canvas.getBoundingClientRect();
      dpr = Math.min(CONFIG.dprCap, Math.max(1, window.devicePixelRatio || 1));
      W = Math.max(1, Math.floor(rect.width  * dpr));
      H = Math.max(1, Math.floor(rect.height * dpr));
      canvas.width  = W;
      canvas.height = H;

      // start with requested spacing; raise if dot count exceeds cap
      spacingDevice = Math.max(4 * dpr, CONFIG.spacing * dpr);
      let cols = Math.ceil(W / spacingDevice) + 2;
      let rows = Math.ceil(H / spacingDevice) + 2;
      let est = cols * rows;

      if (est > CONFIG.maxDots) {
        const scale = Math.sqrt(est / CONFIG.maxDots);
        spacingDevice *= scale;
        cols = Math.ceil(W / spacingDevice) + 2;
        rows = Math.ceil(H / spacingDevice) + 2;
      }

      points.length = 0;
      const step = spacingDevice, half = step * 0.5;
      for (let y = -1; y <= Math.ceil(H/step); y++){
        const gy = y * step + half;
        for (let x = -1; x <= Math.ceil(W/step); x++){
          points.push({ x: x * step + half, y: gy });
        }
      }
    }

    // Helpers
    function smoothstep(edge0, edge1, x){
      const t = Math.max(0, Math.min(1, (x - edge0) / Math.max(1e-6, edge1 - edge0)));
      return t * t * (3 - 2 * t);
    }

    // Animation loop (time-based)
    const frameInterval = 1000 / Math.max(1, CONFIG.targetFPS|0);
    let last = performance.now();

    function draw(now){
      const dt = now - last;
      if (dt < frameInterval) { requestAnimationFrame(draw); return; }
      last = now;

      // pointer ease (time-based to keep feel consistent)
      const ease = 0.18 * (dt / 16.67); // ~0.18 @60fps
      state.px += (state.tx - state.px) * ease;
      state.py += (state.ty - state.py) * ease;

      // transparent clear (no background paint)
      ctx.globalCompositeOperation = "source-over";
      ctx.clearRect(0, 0, W, H);

      const baseR = CONFIG.baseRadius * dpr;

      // local influence + feather (device px)
      const sigmaDevice   = CONFIG.sigma * dpr;
      const localR        = (CONFIG.localRadiusMult ?? 2.6) * sigmaDevice;
      const featherWidth  = Math.max(2, (CONFIG.edgeFeatherMult ?? 0.9) * sigmaDevice);

      // Gaussian falloff (device px)
      const invSigma2Device = 1 / (2 * sigmaDevice * sigmaDevice);

      // chroma setup
      const useChroma = !!(CONFIG.chroma && CONFIG.chroma.enabled);
      const alphaScale = Math.max(0, Math.min(1, CONFIG.chroma?.alphaScale ?? 0.65));
      const rOffX = ((CONFIG.chroma?.r?.x) ?? 0) * dpr;
      const rOffY = ((CONFIG.chroma?.r?.y) ?? 0) * dpr;
      const gOffX = ((CONFIG.chroma?.g?.x) ?? 0) * dpr;
      const gOffY = ((CONFIG.chroma?.g?.y) ?? 0) * dpr;
      const bOffX = ((CONFIG.chroma?.b?.x) ?? 0) * dpr;
      const bOffY = ((CONFIG.chroma?.b?.y) ?? 0) * dpr;
      const additive = useChroma && CONFIG.chroma.mode === "lighter";

      for (let i = 0, n = points.length; i < n; i++) {
        const p = points[i];
        const dx = p.x - state.px;
        const dy = p.y - state.py;
        const d2 = dx*dx + dy*dy;

        // distance & weights
        const dist = Math.sqrt(d2);
        const g = Math.exp(-d2 * invSigma2Device); // Gaussian peak at center
        // feathered clamp: 1 inside localR, smoothly → 0 across feather band
        const clamp = 1 - smoothstep(localR, localR + featherWidth, dist);
        const eff = g * clamp; // effective influence (0..1)

        // base position
        let x = p.x, y = p.y;

        // displacement inward (scaled by eff)
        if (eff > 0.0001) {
          const invLen = 1 / Math.sqrt(d2 + 1e-6);
          const ux = dx * invLen, uy = dy * invLen;
          const disp = CONFIG.amp * dpr * eff;
          x = p.x - ux * disp;
          y = p.y - uy * disp;
        }

        // radius & grayscale blended by eff
        const r = Math.max(baseR * 0.35, baseR * (1 - 0.7 * eff));
        let gray = CONFIG.grayBase - CONFIG.grayDepth * eff;
        if (gray < 0) gray = 0; else if (gray > 255) gray = 255;

        // quantize to device pixels for crisp squares
        const qx = Math.round(x);
        const qy = Math.round(y);
        const s = r + r;

        if (useChroma && eff > 0.0001) {
          const alpha = (gray / 255) * alphaScale;

          if (additive) ctx.globalCompositeOperation = "lighter";
          // R
          ctx.fillStyle = `rgba(255,0,0,${alpha})`;
          ctx.fillRect(qx + rOffX - r, qy + rOffY - r, s, s);
          // G
          ctx.fillStyle = `rgba(0,255,0,${alpha})`;
          ctx.fillRect(qx + gOffX - r, qy + gOffY - r, s, s);
          // B
          ctx.fillStyle = `rgba(0,0,255,${alpha})`;
          ctx.fillRect(qx + bOffX - r, qy + bOffY - r, s, s);
          if (additive) ctx.globalCompositeOperation = "source-over";
        } else {
          const g255 = gray | 0;
          ctx.fillStyle = `rgb(${g255},${g255},${g255})`;
          ctx.fillRect(qx - r, qy - r, s, s);
        }
      }

      // restore default blend for anything drawn later
      ctx.globalCompositeOperation = "source-over";
      requestAnimationFrame(draw);
    }

    // init & observers
    const ro = new ResizeObserver(rebuildGrid);
    ro.observe(canvas.parentElement ?? canvas);
    rebuildGrid();

    // seed pointer to center so it animates even before input
    state.tx = (W / dpr) * 0.5 * dpr;
    state.ty = (H / dpr) * 0.5 * dpr;
    state.px = state.tx; state.py = state.ty;

    requestAnimationFrame(draw);
  }
}
</script>

---
/* TopoDots — greyscale valley with safe blur + visibility toggles */
---
<style>
  .topo-wrap {
    position: relative;
    width: 100%;
    height: min(80vh, 900px); /* ensure height > 0 or you won't see anything */
    overflow: hidden;
    border-radius: 12px;
    background: #0a0a0a; /* bg must contrast with dots */
  }
  
  canvas { display:block; width:100%; height:100%; }
  .hint {
    position:absolute; inset:auto 10px 10px auto;
    font:12px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif;
    color:#bbb; opacity:.8; user-select:none; pointer-events:none;
    background:rgba(0,0,0,.35); padding:.3rem .5rem; border-radius:.5rem; backdrop-filter: blur(6px);
  }
</style>

<div class="topo-wrap">
  <canvas id="topo"></canvas>
  <div class="hint"></div>
</div>

<script>
// @ts-nocheck  // keep JS strictness from blocking during debugging

// ---- CONFIG (edit these) ----
const CONFIG = {
  spacing: 18,        // px between dots (smaller = denser)
  baseRadius: 2.6,    // 🔁 bigger while debugging so dots are obvious
  amp: 10,            // displacement near cursor
  sigma: 160,         // influence radius
  ridge: false,       // false = pull inward (valley)
  bandStrength: 0.25, // contour contrast; set 0 for flat greys
  bandPeriod: 18,     // distance between contour rings
  grayBase: 235,      // dot grey far from cursor (0-255)
  grayDepth: 60,      // darker near center (0-255); 0 = no shading
  bg: "#0a0a0a",
  blur: 0,            // Gaussian blur in px (0..6). Set 0 while debugging
  // DEBUG toggles:
  debugBigDots: false, // true => very large dots to confirm rendering
  debugLog: true,       // logs support info once
  // --- Chroma offsets (RGB separation) ---
chroma: {
  enabled: true,          // master toggle
  mode: "lighter",        // "lighter" blends channels on dark bg
  alphaScale: 0.85,       // per-channel opacity (0..1)
  // offsets in CSS px (we’ll scale by DPR internally)
  r: { x:  -1.5, y:  0 },  // red:   right
  g: { x: 1.5, y:  1.0 },// green: left + down
  b: { x: 1.5, y:  0 },  // blue:  left
},

};

// Grab canvas and context
const el = document.getElementById("topo");
if (!(el instanceof HTMLCanvasElement)) {
  console.warn("[TopoDots] #topo not found or not a <canvas>");
} else {
  const canvas = el;
  const ctx = canvas.getContext("2d", { alpha: false });
  if (!ctx) {
    console.warn("[TopoDots] 2D context unavailable");
  } else {
    const supportsCtxFilter = ('filter' in ctx);
    if (CONFIG.debugLog) console.log("[TopoDots] ctx.filter supported:", supportsCtxFilter);

    let dpr = Math.max(1, window.devicePixelRatio || 1);
    let W = 0, H = 0, cols = 0, rows = 0;
    /** @type {{x:number,y:number}[]} */
    let points = [];
    const state = { tx:0, ty:0, px:0, py:0, hasMouse:false };

    function resize(){
      const rect = canvas.getBoundingClientRect();
      W = Math.max(1, Math.floor(rect.width  * dpr));
      H = Math.max(1, Math.floor(rect.height * dpr));
      canvas.width  = W;
      canvas.height = H;

      const spacing = CONFIG.spacing * dpr;
      cols = Math.ceil(W / spacing) + 2;
      rows = Math.ceil(H / spacing) + 2;

      points = [];
      for (let y=-1; y<=rows-2; y++){
        for (let x=-1; x<=cols-2; x++){
          points.push({ x: x*spacing + spacing*0.5, y: y*spacing + spacing*0.5 });
        }
      }
    }

    function setTarget(x, y){
      state.tx = x * dpr;
      state.ty = y * dpr;
      state.hasMouse = true;
    }

    canvas.addEventListener("pointermove", (e) => setTarget(e.offsetX, e.offsetY));
    canvas.addEventListener("pointerdown",  (e) => setTarget(e.offsetX, e.offsetY));
    canvas.addEventListener("pointerleave", () => (state.hasMouse = false));

    function lerp(a,b,t){ return a + (b-a)*t; }

    function draw(){
      // Smooth pointer
      const ease = 0.15;
      state.px = lerp(state.px, state.tx, ease);
      state.py = lerp(state.py, state.ty, ease);


      // Clear
      ctx.fillStyle = CONFIG.bg;
      ctx.fillRect(0, 0, W, H);

      // Enable additive-like blending for color channels
      ctx.globalCompositeOperation = (CONFIG.chroma?.enabled && CONFIG.chroma.mode === "lighter")
        ? "lighter"
        : "source-over";

      // Safe blur application
      const blurPx = Math.max(0, Math.min(6, Number(CONFIG.blur) || 0));
      if (supportsCtxFilter) {
        ctx.filter = blurPx > 0 ? `blur(${blurPx}px)` : "none";
        // ensure CSS filter is off if we previously used it
        canvas.style.filter = "none";
      } else {
        // CSS fallback (affects whole canvas)
        canvas.style.filter = blurPx > 0 ? `blur(${blurPx}px)` : "none";
      }

      // Precompute
      const baseR = (CONFIG.debugBigDots ? 5.5 : CONFIG.baseRadius) * dpr; // big dots in debug mode
      const invSigma2 = 1 / (2 * CONFIG.sigma * CONFIG.sigma);
      const sign = CONFIG.ridge ? 1 : -1; // ridge=false -> -1 (pull inward)

      for (let i=0, n=points.length; i<n; i++){
        const p = points[i];
        const dx = p.x - state.px;
        const dy = p.y - state.py;
        const d2 = dx*dx + dy*dy;

        const g = Math.exp(-d2 * invSigma2);         // 0..1
        const disp = CONFIG.amp * dpr * g;
        const invLen = 1 / Math.sqrt(d2 + 1e-6);
        const ux = dx * invLen, uy = dy * invLen;

        const x = p.x + sign * ux * disp;
        const y = p.y + sign * uy * disp;

        // shrink near center (valley look)
        const r = Math.max(baseR * 0.35, baseR * (1 - 0.7 * g));

        // greyscale with optional contour banding
        const band = 0.5 + 0.5 * Math.cos((Math.sqrt(d2) / (CONFIG.bandPeriod * dpr)) * 2*Math.PI);
        const bandMix = CONFIG.bandStrength * band;
        const grayNear = CONFIG.grayBase - CONFIG.grayDepth * g; // darker near center
        const gray = Math.round(lerp(grayNear, CONFIG.grayBase, 0.45 + bandMix));
        const clamped = Math.max(0, Math.min(255, gray));
        ctx.fillStyle = `rgb(${clamped},${clamped},${clamped})`;

        const s = r*2;
        ctx.fillRect(x - r, y - r, s, s);
      }

      if (supportsCtxFilter) ctx.filter = "none"; // don’t leak to next frame

      requestAnimationFrame(draw);
    }

    // Observe size
    const parent = canvas.parentElement;
    if (parent) {
      const ro = new ResizeObserver(() => resize());
      ro.observe(parent);
    }

    // Init
    resize();
    state.tx = (W/dpr)/2; state.ty = (H/dpr)/2;
    state.px = state.tx*dpr; state.py = state.ty*dpr;
    requestAnimationFrame(draw);

    // Re-check DPR on change (optional)
    const mm = window.matchMedia?.(`(resolution: ${dpr}dppx)`);
    mm?.addEventListener?.("change", () => { dpr = Math.max(1, window.devicePixelRatio || 1); resize(); });
  }
}
</script>

---
export interface Item {
  src: string | { src: string };
  label?: string;
  href?: string;
  /** optional per-item proportional overrides (used only in proportional mode) */
  scale?: number;
  posX?: string; // e.g. "50%", "40%"
  posY?: string; // e.g. "50%", "55%"
}

export interface Props {
  items?: Item[];
  targetSelector?: string;

  /** Host positioning (relative to where you place the component) */
  top?: string; bottom?: string; left?: string; right?: string;
  centerX?: boolean; centerY?: boolean;
  offsetX?: string; offsetY?: string;
  z?: number;

  /** Frame sizing / look */
  frameMaxWidth?: string;           // e.g. "min(92vw, 960px)" or "100%"
  frameAspect?: string;             // used in proportional mode
  frameRadius?: number;             // px
  frameScale?: number;              // used in proportional mode

  /** Arrow art & placement (relative to frame center) */
  leftArrow?: string | { src: string };
  rightArrow?: string | { src: string };
  leftX?: string;  leftY?: string;  leftScale?: number;
  rightX?: string; rightY?: string; rightScale?: number;
  arrowButtonSize?: string;         // e.g. "56px"
  arrowIconWidth?: string;          // e.g. "34px"

  /** Behavior */
  navigateOnClick?: boolean;
  enablePreload?: boolean;

  /**
   * FILL MODE:
   * "fill"         -> frame fills the slot exactly (ignores aspect/scale; simplest autosize)
   * "proportional" -> frame keeps aspect; use imageFit/imageScale/pos to tune
   */
  mode?: "fill" | "proportional";

  /** Proportional image controls (used only when mode="proportional") */
  imageFit?: "cover" | "contain";
  imageScale?: number;
  imagePosX?: string;
  imagePosY?: string;

  class?: string;
}

const {
  items = [],
  targetSelector = "#enter-stage",

  top = "0", bottom = "0", left = "0", right = "0",
  centerX = false, centerY = false,
  offsetX = "0", offsetY = "0", z = 60,

  frameMaxWidth = "100%",
  frameAspect = "16 / 9",
  frameRadius = 12,
  frameScale = 1,

  leftArrow, rightArrow,
  leftX = "-56%",  leftY = "0%",   leftScale = 1.05,
  rightX = "56%",  rightY = "0%",  rightScale = 1.05,
  arrowButtonSize = "56px",
  arrowIconWidth = "34px",

  navigateOnClick = false,
  enablePreload = true,
  mode = "fill",

  imageFit = "cover",
  imageScale = 1.02,        // tiny seam insurance; set 1 if you don’t want it
  imagePosX = "50%",
  imagePosY = "50%",

  class: className = "",
} = Astro.props;

const toUrl = (x: any) => typeof x === "string" ? x : x?.src;
const normalized = items.map(it => ({
  src: toUrl(it.src),
  label: it.label || "",
  href: it.href || "",
  scale: it.scale,
  posX: it.posX,
  posY: it.posY,
}));
const lUrl = leftArrow ? toUrl(leftArrow) : null;
const rUrl = rightArrow ? toUrl(rightArrow) : null;

// translate center flags into a translate string
const tx = `${centerX ? "-50%" : "0"} + ${offsetX}`;
const ty = `${centerY ? "-50%" : "0"} + ${offsetY}`;
---

<style>
  .carousel-host{
    position:absolute;
    opacity:0; pointer-events:none;
    transition: opacity 200ms ease;
    top: var(--host-top);
    bottom: var(--host-bottom);
    left: var(--host-left);
    right: var(--host-right);
    transform: translate(calc(var(--host-tx)), calc(var(--host-ty)));
    z-index: var(--z);
  }
  .carousel-host.is-on{ opacity:1; pointer-events:auto; }

  .shell{ position:relative; width: var(--frameW); height: 100%; }

  /* FRAME: two modes */
  .frame{
    position: relative;
    width: 100%;
  }
  /* fill mode: frame matches slot exactly (no aspect/scale) */
  .frame.fill{
    height: 100%;
  }
  /* proportional mode: keep aspect & allow scale */
  .frame.prop{
    aspect-ratio: var(--aspect);
    transform: scale(var(--frameScale));
    transform-origin: center;
  }

  /* clipper with rounded corners, transparent background (no black box) */
  .mask{
    position: absolute; inset: 0;
    border-radius: var(--radius);
    overflow: hidden;
    background: transparent;
    box-shadow: none;
  }

  /* the image obeys CSS vars (proportional controls only matter in proportional mode) */
  .mask img{
    display:block; width:100%; height:100%;
    object-fit: var(--img-fit);
    object-position: var(--img-pos-x) var(--img-pos-y);
    transform: scale(var(--img-scale));
    user-select:none; -webkit-user-drag:none;
  }

  /* arrows positioned from frame center */
  .nav{
    -webkit-tap-highlight-color: transparent;
    position:absolute; left:50%; top:50%;
    width: var(--btnSize); height: var(--btnSize);
    margin:0; padding:0; border:0; border-radius:9999px; background:transparent; cursor:pointer;
    display:grid; place-items:center;
    transform: translate(calc(-50% + var(--x)), calc(-50% + var(--y))) scale(var(--s));
    filter: brightness(var(--b,1));
    transition: filter 120ms ease, transform 120ms ease;
  }
  .nav:hover  { --b:.92; }
  .nav:active { --b:.85; transform: translate(calc(-50% + var(--x)), calc(-50% + var(--y))) scale(calc(var(--s) * 1.05)); }
  .nav img{ width: var(--iconW); height:auto; display:block; pointer-events:none; }
  .nav.left  img{ transform: rotate(90deg); }
  .nav.right img{ transform: rotate(-90deg); }
</style>

<div
  class={`carousel-host ${className}`}
  data-target={targetSelector}
  data-items={JSON.stringify(normalized)}
  data-nav={navigateOnClick ? "1" : "0"}
  data-preload={enablePreload ? "1" : "0"}
  data-mode={mode}
  style={`
    --z:${z};
    --host-top:${top}; --host-bottom:${bottom}; --host-left:${left}; --host-right:${right};
    --host-tx:${tx};   --host-ty:${ty};
    --frameW:${frameMaxWidth};
    --aspect:${frameAspect};
    --radius:${frameRadius}px;
    --frameScale:${frameScale};
    --btnSize:${arrowButtonSize};
    --iconW:${arrowIconWidth};
    --img-fit:${imageFit};
    --img-scale:${imageScale};
    --img-pos-x:${imagePosX};
    --img-pos-y:${imagePosY};
  `}
>
  <div class="shell">
    <div class={`frame ${mode === "fill" ? "fill" : "prop"}`}>
      <div class="mask">
        <img id="cc-img" alt="" loading="eager" decoding="async" fetchpriority="high" />
      </div>

      <!-- LEFT -->
      <button
        class="nav left"
        type="button"
        aria-label="Previous"
        style={`--x:${leftX}; --y:${leftY}; --s:${leftScale};`}
      >
        {lUrl ? <img src={lUrl} alt="" /> : <span aria-hidden="true" style="font-size:28px;line-height:1">‹</span>}
      </button>

      <!-- RIGHT -->
      <button
        class="nav right"
        type="button"
        aria-label="Next"
        style={`--x:${rightX}; --y:${rightY}; --s:${rightScale};`}
      >
        {rUrl ? <img src={rUrl} alt="" /> : <span aria-hidden="true" style="font-size:28px;line-height:1">›</span>}
      </button>
    </div>
  </div>
</div>

<script is:inline>
(() => {
  const host = document.currentScript?.previousElementSibling;
  if (!host) return;

  // read items
  let items = [];
  try { items = JSON.parse(host.getAttribute('data-items') || '[]'); } catch {}
  if (!items.length) return;

  const img   = host.querySelector('#cc-img');
  const left  = host.querySelector('.nav.left');
  const right = host.querySelector('.nav.right');
  const navGo = host.getAttribute('data-nav') === '1';
  const doPreload = host.getAttribute('data-preload') !== '0';
  const mode = host.getAttribute('data-mode') || 'fill';

  // PRELOAD
  const cache = new Map();
  const inflight = new Map();
  function preload(src){
    if (!doPreload || !src) return Promise.resolve(null);
    if (cache.has(src)) return Promise.resolve(cache.get(src));
    if (inflight.has(src)) return inflight.get(src);
    const p = new Promise((resolve) => {
      const im = new Image();
      im.decoding = 'async';
      im.loading = 'eager';
      im.src = src;
      const done = () => (im.decode?.() ?? Promise.resolve()).finally(() => { cache.set(src, im); resolve(im); });
      if (im.complete) done();
      else im.addEventListener('load', done, { once:true });
    }).finally(() => inflight.delete(src));
    inflight.set(src, p);
    return p;
  }
  function preloadNeighbors(idx){
    const n = items.length;
    if (!n) return;
    const prev = (idx - 1 + n) % n, next = (idx + 1) % n;
    preload(items[prev]?.src); preload(items[next]?.src);
  }

  // RENDER
  let i = 0;
  function setImage(it){
    const src = it?.src; if (!src) return;
    // per-item proportional overrides (only meaningful in proportional mode):
    if (mode === 'proportional') {
      const scale = it.scale ?? (parseFloat(getComputedStyle(host).getPropertyValue('--img-scale')) || 1);
      const posX  = it.posX  ?? (getComputedStyle(host).getPropertyValue('--img-pos-x') || '50%');
      const posY  = it.posY  ?? (getComputedStyle(host).getPropertyValue('--img-pos-y') || '50%');

      img.style.setProperty('--img-scale', String(scale));
      img.style.setProperty('--img-pos-x', posX.trim());
      img.style.setProperty('--img-pos-y', posY.trim());
    }
    const cached = cache.get(src);
    if (cached?.complete) { img.src = cached.src; img.alt = it?.label || ''; return; }
    preload(src).then(im => {
      if (!im) { img.src = src; img.alt = it?.label || ''; return; }
      if (items[i]?.src === src) { img.src = im.src; img.alt = it?.label || ''; }
    });
  }
  function render(){ const it = items[i]; setImage(it); preloadNeighbors(i); }
  function next(n){ i = (i + n + items.length) % items.length; render(); }

  left?.addEventListener('click',  () => next(-1));
  right?.addEventListener('click', () => next(+1));

  if (navGo){
    img.style.cursor = 'pointer';
    img.addEventListener('click', () => {
      const href = items[i]?.href;
      if (href) window.location.href = href;
    });
  }

// ACTIVATION + ESC + WARM-UP (drop-in replacement)
const targetSel = host.getAttribute('data-target') || '#enter-stage';
const target = document.querySelector(targetSel);

function turnOn(){
  if (host.classList.contains('is-on')) return;
  host.classList.add('is-on');
  render();
}

// 1) Immediate state (in case activation happened before mount)
if (target?.getAttribute('data-entered') === 'true') turnOn();

// 2) Custom event from HoldEnterButton
window.addEventListener('enter:activated', (e) => {
  const sel = e?.detail?.selector;
  if (!sel || sel === targetSel) turnOn();
}, { passive: true });

// 3) Fallback: watch the target's attribute
if (target){
  const mo = new MutationObserver(() => {
    if (target.getAttribute('data-entered') === 'true') turnOn();
  });
  mo.observe(target, { attributes: true, attributeFilter: ['data-entered'] });
}

// 4) ESC to close and fully restore the button
window.addEventListener('keydown', (e) => {
  if (e.key !== 'Escape') return;

  host.classList.remove('is-on');
  target?.removeAttribute('data-entered');

  const wrap = document.querySelector('.enter-wrap');
  if (!wrap) return;
  wrap.style.display = '';

  const btn  = wrap.querySelector('.enter-btn');
  const rect = wrap.querySelector('.enter-stroke');

  if (btn){
    btn.removeAttribute('aria-disabled');
    btn.setAttribute('aria-pressed','false');
    btn.style.opacity = '';
    btn.style.removeProperty('--press');
  }

  if (rect){
    let total = 0;
    try {
      total = rect.getTotalLength();
    } catch {
      const W  = parseFloat(rect.getAttribute('width')  || '197');
      const H  = parseFloat(rect.getAttribute('height') || '69');
      const rx = parseFloat(wrap.getAttribute('data-rx') || '10');
      const r  = Math.min(rx, Math.min(W, H) * 0.5);
      total = 2 * (W + H - 2 * r) + 2 * Math.PI * r;
    }
    rect.style.opacity = '0';
    rect.style.strokeDasharray = `0 ${total}`;
  }
}, { passive:true });

// 5) Preload warm-up
if (doPreload) {
  preload(items[0]?.src).then(() => {
    if (host.classList.contains('is-on')) render();
  });
  preloadNeighbors(0);
  const rest = () => { for (let k = 2; k < items.length; k++) preload(items[k]?.src); };
  (window.requestIdleCallback ? requestIdleCallback(rest, { timeout: 1500 }) : setTimeout(rest, 300));
}
})();
</script>

